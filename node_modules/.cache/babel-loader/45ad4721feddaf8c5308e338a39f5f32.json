{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\nexports.default = globsToMatcher;\nfunction _picomatch() {\n  const data = _interopRequireDefault(require('picomatch'));\n  _picomatch = function () {\n    return data;\n  };\n  return data;\n}\nvar _replacePathSepForGlob = _interopRequireDefault(require('./replacePathSepForGlob'));\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\n/**\n * Copyright (c) Facebook, Inc. and its affiliates. All Rights Reserved.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nconst globsToMatchersMap = new Map();\nconst picomatchOptions = {\n  dot: true\n};\n/**\n * Converts a list of globs into a function that matches a path against the\n * globs.\n *\n * Every time picomatch is called, it will parse the glob strings and turn\n * them into regexp instances. Instead of calling picomatch repeatedly with\n * the same globs, we can use this function which will build the picomatch\n * matchers ahead of time and then have an optimized path for determining\n * whether an individual path matches.\n *\n * This function is intended to match the behavior of `micromatch()`.\n *\n * @example\n * const isMatch = globsToMatcher(['*.js', '!*.test.js']);\n * isMatch('pizza.js'); // true\n * isMatch('pizza.test.js'); // false\n */\n\nfunction globsToMatcher(globs) {\n  if (globs.length === 0) {\n    // Since there were no globs given, we can simply have a fast path here and\n    // return with a very simple function.\n    return () => false;\n  }\n  const matchers = globs.map(glob => {\n    if (!globsToMatchersMap.has(glob)) {\n      const isMatch = (0, _picomatch().default)(glob, picomatchOptions, true);\n      const matcher = {\n        isMatch,\n        // Matchers that are negated have different behavior than matchers that\n        // are not negated, so we need to store this information ahead of time.\n        negated: isMatch.state.negated || !!isMatch.state.negatedExtglob\n      };\n      globsToMatchersMap.set(glob, matcher);\n    }\n    return globsToMatchersMap.get(glob);\n  });\n  return path => {\n    const replacedPath = (0, _replacePathSepForGlob.default)(path);\n    let kept = undefined;\n    let negatives = 0;\n    for (let i = 0; i < matchers.length; i++) {\n      const {\n        isMatch,\n        negated\n      } = matchers[i];\n      if (negated) {\n        negatives++;\n      }\n      const matched = isMatch(replacedPath);\n      if (!matched && negated) {\n        // The path was not matched, and the matcher is a negated matcher, so we\n        // want to omit the path. This means that the negative matcher is\n        // filtering the path out.\n        kept = false;\n      } else if (matched && !negated) {\n        // The path was matched, and the matcher is not a negated matcher, so we\n        // want to keep the path.\n        kept = true;\n      }\n    } // If all of the globs were negative globs, then we want to include the path\n    // as long as it was not explicitly not kept. Otherwise only include\n    // the path if it was kept. This allows sets of globs that are all negated\n    // to allow some paths to be matched, while sets of globs that are mixed\n    // negated and non-negated to cause the negated matchers to only omit paths\n    // and not keep them.\n\n    return negatives === matchers.length ? kept !== false : !!kept;\n  };\n}","map":{"version":3,"names":["Object","defineProperty","exports","value","default","globsToMatcher","_picomatch","data","_interopRequireDefault","require","_replacePathSepForGlob","obj","__esModule","globsToMatchersMap","Map","picomatchOptions","dot","globs","length","matchers","map","glob","has","isMatch","matcher","negated","state","negatedExtglob","set","get","path","replacedPath","kept","undefined","negatives","i","matched"],"sources":["/Users/ujjvalsharma/Desktop/sde-final-project/Tuiter-Project-React/node_modules/jest-util/build/globsToMatcher.js"],"sourcesContent":["'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\nexports.default = globsToMatcher;\n\nfunction _picomatch() {\n  const data = _interopRequireDefault(require('picomatch'));\n\n  _picomatch = function () {\n    return data;\n  };\n\n  return data;\n}\n\nvar _replacePathSepForGlob = _interopRequireDefault(\n  require('./replacePathSepForGlob')\n);\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {default: obj};\n}\n\n/**\n * Copyright (c) Facebook, Inc. and its affiliates. All Rights Reserved.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nconst globsToMatchersMap = new Map();\nconst picomatchOptions = {\n  dot: true\n};\n/**\n * Converts a list of globs into a function that matches a path against the\n * globs.\n *\n * Every time picomatch is called, it will parse the glob strings and turn\n * them into regexp instances. Instead of calling picomatch repeatedly with\n * the same globs, we can use this function which will build the picomatch\n * matchers ahead of time and then have an optimized path for determining\n * whether an individual path matches.\n *\n * This function is intended to match the behavior of `micromatch()`.\n *\n * @example\n * const isMatch = globsToMatcher(['*.js', '!*.test.js']);\n * isMatch('pizza.js'); // true\n * isMatch('pizza.test.js'); // false\n */\n\nfunction globsToMatcher(globs) {\n  if (globs.length === 0) {\n    // Since there were no globs given, we can simply have a fast path here and\n    // return with a very simple function.\n    return () => false;\n  }\n\n  const matchers = globs.map(glob => {\n    if (!globsToMatchersMap.has(glob)) {\n      const isMatch = (0, _picomatch().default)(glob, picomatchOptions, true);\n      const matcher = {\n        isMatch,\n        // Matchers that are negated have different behavior than matchers that\n        // are not negated, so we need to store this information ahead of time.\n        negated: isMatch.state.negated || !!isMatch.state.negatedExtglob\n      };\n      globsToMatchersMap.set(glob, matcher);\n    }\n\n    return globsToMatchersMap.get(glob);\n  });\n  return path => {\n    const replacedPath = (0, _replacePathSepForGlob.default)(path);\n    let kept = undefined;\n    let negatives = 0;\n\n    for (let i = 0; i < matchers.length; i++) {\n      const {isMatch, negated} = matchers[i];\n\n      if (negated) {\n        negatives++;\n      }\n\n      const matched = isMatch(replacedPath);\n\n      if (!matched && negated) {\n        // The path was not matched, and the matcher is a negated matcher, so we\n        // want to omit the path. This means that the negative matcher is\n        // filtering the path out.\n        kept = false;\n      } else if (matched && !negated) {\n        // The path was matched, and the matcher is not a negated matcher, so we\n        // want to keep the path.\n        kept = true;\n      }\n    } // If all of the globs were negative globs, then we want to include the path\n    // as long as it was not explicitly not kept. Otherwise only include\n    // the path if it was kept. This allows sets of globs that are all negated\n    // to allow some paths to be matched, while sets of globs that are mixed\n    // negated and non-negated to cause the negated matchers to only omit paths\n    // and not keep them.\n\n    return negatives === matchers.length ? kept !== false : !!kept;\n  };\n}\n"],"mappings":"AAAA,YAAY;;AAEZA,MAAM,CAACC,cAAc,CAACC,OAAO,EAAE,YAAY,EAAE;EAC3CC,KAAK,EAAE;AACT,CAAC,CAAC;AACFD,OAAO,CAACE,OAAO,GAAGC,cAAc;AAEhC,SAASC,UAAU,GAAG;EACpB,MAAMC,IAAI,GAAGC,sBAAsB,CAACC,OAAO,CAAC,WAAW,CAAC,CAAC;EAEzDH,UAAU,GAAG,YAAY;IACvB,OAAOC,IAAI;EACb,CAAC;EAED,OAAOA,IAAI;AACb;AAEA,IAAIG,sBAAsB,GAAGF,sBAAsB,CACjDC,OAAO,CAAC,yBAAyB,CAAC,CACnC;AAED,SAASD,sBAAsB,CAACG,GAAG,EAAE;EACnC,OAAOA,GAAG,IAAIA,GAAG,CAACC,UAAU,GAAGD,GAAG,GAAG;IAACP,OAAO,EAAEO;EAAG,CAAC;AACrD;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,MAAME,kBAAkB,GAAG,IAAIC,GAAG,EAAE;AACpC,MAAMC,gBAAgB,GAAG;EACvBC,GAAG,EAAE;AACP,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,SAASX,cAAc,CAACY,KAAK,EAAE;EAC7B,IAAIA,KAAK,CAACC,MAAM,KAAK,CAAC,EAAE;IACtB;IACA;IACA,OAAO,MAAM,KAAK;EACpB;EAEA,MAAMC,QAAQ,GAAGF,KAAK,CAACG,GAAG,CAACC,IAAI,IAAI;IACjC,IAAI,CAACR,kBAAkB,CAACS,GAAG,CAACD,IAAI,CAAC,EAAE;MACjC,MAAME,OAAO,GAAG,CAAC,CAAC,EAAEjB,UAAU,EAAE,CAACF,OAAO,EAAEiB,IAAI,EAAEN,gBAAgB,EAAE,IAAI,CAAC;MACvE,MAAMS,OAAO,GAAG;QACdD,OAAO;QACP;QACA;QACAE,OAAO,EAAEF,OAAO,CAACG,KAAK,CAACD,OAAO,IAAI,CAAC,CAACF,OAAO,CAACG,KAAK,CAACC;MACpD,CAAC;MACDd,kBAAkB,CAACe,GAAG,CAACP,IAAI,EAAEG,OAAO,CAAC;IACvC;IAEA,OAAOX,kBAAkB,CAACgB,GAAG,CAACR,IAAI,CAAC;EACrC,CAAC,CAAC;EACF,OAAOS,IAAI,IAAI;IACb,MAAMC,YAAY,GAAG,CAAC,CAAC,EAAErB,sBAAsB,CAACN,OAAO,EAAE0B,IAAI,CAAC;IAC9D,IAAIE,IAAI,GAAGC,SAAS;IACpB,IAAIC,SAAS,GAAG,CAAC;IAEjB,KAAK,IAAIC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGhB,QAAQ,CAACD,MAAM,EAAEiB,CAAC,EAAE,EAAE;MACxC,MAAM;QAACZ,OAAO;QAAEE;MAAO,CAAC,GAAGN,QAAQ,CAACgB,CAAC,CAAC;MAEtC,IAAIV,OAAO,EAAE;QACXS,SAAS,EAAE;MACb;MAEA,MAAME,OAAO,GAAGb,OAAO,CAACQ,YAAY,CAAC;MAErC,IAAI,CAACK,OAAO,IAAIX,OAAO,EAAE;QACvB;QACA;QACA;QACAO,IAAI,GAAG,KAAK;MACd,CAAC,MAAM,IAAII,OAAO,IAAI,CAACX,OAAO,EAAE;QAC9B;QACA;QACAO,IAAI,GAAG,IAAI;MACb;IACF,CAAC,CAAC;IACF;IACA;IACA;IACA;IACA;;IAEA,OAAOE,SAAS,KAAKf,QAAQ,CAACD,MAAM,GAAGc,IAAI,KAAK,KAAK,GAAG,CAAC,CAACA,IAAI;EAChE,CAAC;AACH"},"metadata":{},"sourceType":"script"}